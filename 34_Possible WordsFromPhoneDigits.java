/* 
Question Section:
Given a keypad as shown in the diagram, and an array `arr[ ]`, 
the task is to list all words in lexicographical increasing order which are generated by pressing numbers from the array.

Examples:
Input: arr[] = [2, 3, 4]
Output: adg adh adi aeg aeh aei afg afh afi bdg bdh bdi beg beh bei bfg bfh bfi cdg cdh cdi ceg ceh cei cfg cfh cfi 

Constraints:
1 ≤ arr.size() ≤ 10
2 ≤ arr[i] ≤ 9
*/

/*
Understanding the Problem Statement:
1. The problem asks us to generate all possible words by mapping numbers to letters (like on an old-style phone keypad).
2. Each digit corresponds to multiple characters (e.g., '2' maps to ['a', 'b', 'c']).
3. The task is to generate combinations of these characters based on the input array and sort them lexicographically.

Objective:
Generate and return a list of all possible combinations in lexicographical order based on input digits.
*/

/*
Extracting Information from the Problem Statement:
1. Input data type: Integer array `arr[]` where each element is between 2 and 9.
2. Expected Output: All possible words generated, sorted in lexicographical order.
3. Output return type: List of strings.
4. Time Complexity Expectation: Should efficiently handle up to 10 numbers in the array, with each number having up to 4 characters.
5. Constraints: Numbers in `arr[]` will always be in the range [2, 9].
*/

/*
Thinking Solution for the Problem Statement:
1. Identification Part: 
   - This is a combination generation problem. Each number corresponds to a set of letters.
   - The task involves recursively combining the letters for all numbers in the array.

2. Destructuring:
   - Input: Array of numbers.
   - Output: All combinations of letters corresponding to the numbers.
   - Steps:
     a) Map each number to its letters.
     b) Use recursion or iteration to generate all combinations.
     c) Sort the combinations lexicographically.

3. Conversational Solution:
   - Map digits to letters using a predefined mapping.
   - Use backtracking to form all combinations.
   - Store combinations in a list and sort them before returning.
*/

/*
Conversional Solution into Subtasks:
1. Map digits to corresponding characters using a HashMap.
2. Create a recursive function to generate combinations.
3. Store combinations in a list.
4. Sort the list lexicographically.
5. Print the result.
*/

/* Subtasks for Conversional Solution:
S.no: Subtasks
1. Define a mapping of numbers to their corresponding characters.
2. Create a recursive function to generate combinations.
3. Append each valid combination to a list.
4. Sort the list lexicographically.
5. Print or return the final result.
*/

import java.util.*;

public class KeypadWordCombinations {
    /* Subtask 1: Define the mapping of digits to characters */
    private static final Map<Integer, String> keypadMapping = new HashMap<>();
    static {
        keypadMapping.put(2, "abc");
        keypadMapping.put(3, "def");
        keypadMapping.put(4, "ghi");
        keypadMapping.put(5, "jkl");
        keypadMapping.put(6, "mno");
        keypadMapping.put(7, "pqrs");
        keypadMapping.put(8, "tuv");
        keypadMapping.put(9, "wxyz");
    }

    /* Subtask 2: Recursive function to generate combinations */
    public static void generateCombinations(int[] arr, int index, StringBuilder current, List<String> result) {
        // Base case: If index equals array length, add the current combination to the result.
        if (index == arr.length) {
            result.add(current.toString());
            return;
        }
        
        // Fetch the characters corresponding to the current digit.
        String letters = keypadMapping.get(arr[index]);
        
        // Iterate over each character and recurse.
        for (int i = 0; i < letters.length(); i++) {
            current.append(letters.charAt(i)); // Add character to the current combination.
            generateCombinations(arr, index + 1, current, result); // Recurse for the next digit.
            current.deleteCharAt(current.length() - 1); // Backtrack by removing the last character.
        }
    }

    /* Subtask 3: Main function to solve the problem */
    public static List<String> listAllWords(int[] arr) {
        List<String> result = new ArrayList<>();
        generateCombinations(arr, 0, new StringBuilder(), result);
        Collections.sort(result); // Sort the result lexicographically.
        return result;
    }

    /* Main method to test the code */
    public static void main(String[] args) {
        // Test Input
        int[] arr1 = {2, 3, 4};
        int[] arr2 = {3, 4, 5};
        int[] arr3 = {2};

        // Test Outputs
        System.out.println("Output for arr1: " + listAllWords(arr1));
        System.out.println("Output for arr2: " + listAllWords(arr2));
        System.out.println("Output for arr3: " + listAllWords(arr3));
    }
}

/*
Time and Space Complexity Explanation:
1. Time Complexity:
   - For an input array of size `n`, each digit can have up to 4 letters.
   - Total combinations: 4^n.
   - Sorting takes O(k log k), where k = 4^n.
   - Overall complexity: O(4^n + 4^n log(4^n)) ≈ O(4^n log(4^n)).

2. Space Complexity:
   - Space for recursion: O(n) (maximum depth of recursion stack).
   - Space for storing combinations: O(4^n).
   - Total space complexity: O(4^n).
*/

/*
Walkthrough of "for" loop:
1. For each digit, fetch its corresponding characters.
2. Iterate through each character and append it to the current string.
3. Recursively process the next digit.
4. Backtrack after processing all combinations for the current character.
*/

/*
Complete Code Walkthrough:
Input: arr = [2, 3]
Step 1: Fetch 'abc' for 2 and 'def' for 3.
Step 2: Generate combinations: ad, ae, af, bd, be, bf, cd, ce, cf.
Step 3: Sort lexicographically.
Output: [ad, ae, af, bd, be, bf, cd, ce, cf].
*/
